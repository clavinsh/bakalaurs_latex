\begin{center}
    \chapter{Rezultāti}
\end{center}

Praktiskai platformu salīdzināšanai tika izstrādāts etalonuzdevumu ietvars, 
lai šie uzdevumi būtu pēc iespējas viegli atkārtojami citos uzstādījumos, tas
ir, ar citu aparatūru. No 2 definētajiem uzdevumiem un 3 pētamajām GPU
programmēšanas platformām tika izveidoti 8 Docker konteineri ar komandrindas
programmām un praktiski notestēti 6 uz Nvidia RTX 3060 Laptop videokartes:
\begin{itemize}
    \setlength\itemsep{0pt}
    \item golcuda - "Dzīves spēles" uzdevuma konteineris uz CUDA,
    \item golcl - "Dzīves spēles" uzdevuma konteineris uz OpenCL,
    \item golhip:cuda - "Dzīves spēles" uzdevuma konteineris uz ROCm HIP ar CUDA aizmuguri,
    \item golhip:rocm - "Dzīves spēles" uzdevuma konteineris uz ROCm HIP ar ROCm aizmuguri,
    \item sha256cuda - paroļu atgūšanas uzdevuma konteineris uz CUDA,
    \item sha256cl - paroļu atgūšanas uzdevuma konteineris uz OpenCL,
    \item sha256hip:cuda - paroļu atgūšanas uzdevuma konteineris uz ROCm HIP ar CUDA aizmuguri,
    \item sha256hip:rocm - paroļu atgūšanas uzdevuma konteineris uz ROCm HIP ar ROCm aizmuguri.
\end{itemize}

Konteineri tika darbināti automatizēti ar Python skriptiem, kuri sagatavoja
programmām ievaddatus, dažādās to darbināšanas konfigurācijās, visās
permutācijās. Dažādos griezumos apskatīti iegūtie dati no žurnālfailiem, un
kopsummā apstrādāti un analizēti 810 žurnālfaili par CUDA, HIP, OpenCL
dažādajiem GPGPU notikumu izpildes ilgumiem.

Noskaidrots, ka paroļu atguvēja uzdevumā OpenCL darbojās par 30,18\% lēnāk nekā
CUDA, bet ROCm HIP platforma par 2,25\% lēnāk.
"Dzīves spēles" uzdevumā rezultāti sarindojās tieši tāpat, lai gan OpenCL
starpība nebija tik liela kā pirmajā uzdevumā, - OpenCL lēnāks par
7,71\%, bet ROCm HIP par 2,47\%.

Aptuveni šāds sniegums bija gaidāms, jo CUDA un ROCm ir gandrīz identiskas
platformas, turpretī OpenCL konveijerapstrādes modelis, SPIR-V starp-posmu
valodas tulkošana un citas ieviestās abstrakcijas rada papildus virsdarbi. ROCm
virsdarbe ir minimāla, jo ar Nvidia videokartēm tiek atbalstīta CUDA
kompilatora aizmugursistēma HIP rakstītām programmām. Tāpēc praktiski
visos rādītājos CUDA bija ātrākā, ROCm HIP bija otrajā vietā, OpenCL - trešajā.

Visās trijās platformās abos uzdevumos bija manāmas rimstošas svārstības
kodolu izpildes laikos, bet papildus tika novērotas konsekventas variācijas un
nestabilitāte kodolu izpildē ar OpenCL un ROCm platformām, kur šīs svārstības
aptuveni 80\% gadījumu nerimst. Pats periods arī nav vienmērīgs, un visos
gadījumos vērojama lielāka nosliece uz mazākām vērtībām. Tāpēc, apskatot
kodolu izpildes laikus kā histogrammas pēc biežumiem, CUDA risinājums veido
vienu pīķi, bet OpenCL un ROCm - divus.

Bet šīs svārstības nav salīdzinoši lielas - ar amplitūdu no 0,0212\si{\ms} līdz
0,1147\si{\ms} kodoliem, kuru vidējais izpildes laiks ir no 0,6446\si{\ms} līdz
2.001\si{\ms}.

Līdzīgi tika apskatīta GPU atmiņas izveide un datu pārsūtīšana, bet šajos
mērījumos iepriekšminētās svārstības netika novērotas nevienā platformā. Datu
buferi \(2^{20}\) parolēm, kas aizņem aptuveni 33.55MiB, tiek nosūtīti vidēji
no 2.7472\si{\ms} līdz 6.4135\si{\ms} ar amplitūdu no 0.03764\si{\ms}  līdz
0.0558\si{\ms}.
